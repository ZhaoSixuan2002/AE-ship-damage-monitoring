# 工作区重组原则

## 1. 脚本命名规范

- **前缀编号**：每个脚本使用 `01_`, `02_`, `03_` 等前缀
- **执行顺序**：按文件名排序 = 按逻辑执行顺序
- **主脚本后缀 `_main`**：每个阶段的主脚本使用 `_main` 后缀
  - 例如：`01_generate_training_data_main.py`
- **辅助脚本命名规则**：`{前缀数字}_{实际含义}_auxiliary.py`
  - 前缀使用对应流程数字（如 `01_`）
  - 中间用实际含义命名（如 `async_postprocess`）
  - 后缀统一为 `_auxiliary`
  - 示例：`01_async_postprocess_auxiliary.py`
  - 辅助脚本参与主流程，由主脚本调用
- **分支工具后缀 `_helper`**：不参与主流程的验证工具等使用 `_helper` 后缀
  - 例如：`09_interactive_vtu_viewer_helper.py`
  - 分支工具是可选的，用于验证、调试等辅助目的
- **使用方式**：从上到下依次执行 `_main` 脚本即可

## 2. 输出文件组织

- **独立输出目录**：每个主脚本的输出放在独立的文件夹内
- **命名规则**：`{脚本前缀和主名}_output/`（基于主脚本名，去掉 `_main` 后缀）
  - 例如：`01_generate_training_data_main.py` → `01_generate_training_data_output/`
  - 例如：`02_preprocess_training_data_main.py` → `02_preprocess_training_data_output/`
- **扁平化结构**：输出目录内不再建立子文件夹，所有文件直接输出到 `_output/` 根目录
- **不使用公共目录**：废弃原有的公共 `output/` 文件夹

## 3. 脚本内容组织

- **主脚本自包含原则**：每个主脚本自包含核心逻辑
- **辅助脚本分离原则**：复杂阶段如需辅助脚本（如异步处理），使用 `{前缀数字}_{实际含义}_auxiliary.py` 命名
- **重复功能内嵌**：重复调用的功能（如绘图）直接写在对应脚本内，不共享代码
- **简化目录结构**：使目录结构即执行流程，一目了然
- **参数自然编写**：参数按自然逻辑顺序直接在脚本中编写，可在对应位置简要注释
- **无需参数集中化**：不需要对每个脚本的参数进行集中化配置和解析
- **废弃工具模块**：不使用 `utils/` 等共享代码目录，代码直接内嵌到各脚本

## 4. 配置文件处理

- **废弃集中配置**：不再使用 `config.py` 和 `config_runtime.py`
- **参数本地化**：每个脚本按自然逻辑顺序编写参数
- **直接修改**：哪个脚本有问题就调哪个脚本的参数，简单直接
- **待删除**：在所有脚本重构完成后，删除 `config.py`、`config_runtime.py` 等旧配置文件

## 5. 特殊情况

- **大数据例外**：数据生成类输出量大的，结果存放在外部原路径（不遵循输出目录规则）
  - 训练数据：仍存储在 `C:/abaqus_gen_data`
  - 验证数据：仍存储在 `C:/abaqus_gen_data_validate_*`

## 6. 预期效果

- ✅ 目录结构即执行流程
- ✅ 主脚本使用 `_main` 后缀，清晰标识主流程
- ✅ 辅助脚本命名：`{前缀数字}_{实际含义}_auxiliary.py`，语义清晰
- ✅ 分支工具使用 `_helper` 后缀，与主流程区分
- ✅ 每个脚本自包含输出
- ✅ 输出目录扁平化，文件查找便捷
- ✅ 便于管理和追踪
- ✅ 执行流程一目了然（01_*_main → 02_*_main → 03_*_main...）
- ✅ 参数按自然逻辑在脚本中编写，无需跨文件查找
- ✅ 分支工具明确标识，可选使用

